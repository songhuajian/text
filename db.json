{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landfarz/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landfarz/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landfarz/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/landfarz/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/landfarz/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.eot","path":"css/font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.woff","path":"css/font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.ttf","path":"css/font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.svg","path":"css/font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landfarz/source/css/images/body.jpg","path":"css/images/body.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landfarz/README.md","hash":"625967b434141eb98fbb7a62a9ec405809481cac","modified":1497238070329},{"_id":"themes/landfarz/_config.yml","hash":"ee8737ec36b74ddf8ca31a1ab2bb7764f0bc1802","modified":1497238070330},{"_id":"themes/landfarz/LICENSE","hash":"ccf796b213c60a50d27e907c11463c30cf979576","modified":1497238070329},{"_id":"source/_posts/AngularJS遇到的问题.md","hash":"c676cab6d29fe2b0523477ed2bf01f1e940ab6dc","modified":1497238070321},{"_id":"source/_posts/CSS3.md","hash":"a83c752ea508863bf4b22598eef5452ad3f8dd04","modified":1497238070322},{"_id":"source/_posts/Angular路由.md","hash":"6b8a3c789e08277e11a4a66261d9c17c38ef6f07","modified":1497238070321},{"_id":"source/_posts/Javascript闭包.md","hash":"2592c47201fb9943aeb044e0f3b87a2b5e9927e7","modified":1497238070327},{"_id":"source/_posts/Javascript面向对象编程.md","hash":"01be126703daa0d3f34bf90d80322e0219acf9d2","modified":1497238070327},{"_id":"source/_posts/Sublime-text-3-部分插件.md","hash":"4563f6356346ae80bee8b20d93654f1202962e3a","modified":1497238070328},{"_id":"themes/landfarz/languages/de.yml","hash":"1ebe2d4f1b48c84e004c933bec65731fb54c9998","modified":1497238070330},{"_id":"source/_posts/Windows下的nodejs管理工具nvm.md","hash":"f1173dffb6872275b9055c3eae4ddb2dc64c9a93","modified":1497238070328},{"_id":"themes/landfarz/languages/default.yml","hash":"360a92ba57b6f7cdfccab4c758f0832f61c6b029","modified":1497238070331},{"_id":"themes/landfarz/languages/es.yml","hash":"727707b95580bbe9773edef4c84a9735fd537742","modified":1497238070331},{"_id":"themes/landfarz/languages/ru.yml","hash":"37161bb9b6cc2dae1f53837185be32e7a0b8abfa","modified":1497238070332},{"_id":"themes/landfarz/languages/zh-CN.yml","hash":"0395331b72062d8a1d7c92e3a45f5f5ca9dda254","modified":1497238070332},{"_id":"themes/landfarz/languages/zh-TW.yml","hash":"2a172dae38a7554b36b031c20dd1625ce12379ed","modified":1497238070333},{"_id":"themes/landfarz/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1497238070343},{"_id":"themes/landfarz/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1497238070343},{"_id":"themes/landfarz/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1497238070344},{"_id":"themes/landfarz/layout/index.ejs","hash":"c7cf84c84c26f1adfc249bc9a7605206fa245f73","modified":1497238070343},{"_id":"themes/landfarz/layout/layout.ejs","hash":"6999916072898aedfe13f4a07211dd1578ad4799","modified":1497238070343},{"_id":"themes/landfarz/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1497238070344},{"_id":"themes/landfarz/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1497238070345},{"_id":"themes/landfarz/layout/_partial/after_footer.ejs","hash":"3a9c81b49e8b9f46d693dad3df1f44e62584a909","modified":1497238070334},{"_id":"themes/landfarz/layout/_partial/archive.ejs","hash":"eaab5ad657f16dfc6cff6f462e1234c3cb8f23a0","modified":1497238070334},{"_id":"themes/landfarz/layout/_partial/comment.ejs","hash":"605ce482540ea710df4c832ee0efcdd9909ce1ee","modified":1497238070335},{"_id":"themes/landfarz/layout/_partial/facebook_comment.ejs","hash":"49ee54e84fe2b70bd9540e2eeba5a85f744941b0","modified":1497238070336},{"_id":"themes/landfarz/layout/_partial/article.ejs","hash":"abd81dff0d4e7fc088ff39c84e0dfcbdb9e3328e","modified":1497238070335},{"_id":"themes/landfarz/layout/_partial/footer.ejs","hash":"7b7badba807c75826622b73385fc852246e09679","modified":1497238070336},{"_id":"themes/landfarz/layout/_partial/google_analytics.ejs","hash":"d70d287956e90e99ba35b2e14cefb477f9203aa0","modified":1497238070336},{"_id":"themes/landfarz/layout/_partial/head.ejs","hash":"50d951b5c24c3a82a31fa46250de813bfe028171","modified":1497238070337},{"_id":"themes/landfarz/layout/_partial/pagination.ejs","hash":"a7df8d2d87c6773b74e8dd1ae044b92d72c5c2b0","modified":1497238070338},{"_id":"themes/landfarz/layout/_partial/header.ejs","hash":"73c45d7426009feb495710b054868a7f10616178","modified":1497238070337},{"_id":"themes/landfarz/layout/_partial/sidebar.ejs","hash":"016441ca9534769d8e151cffe4027686e9c86f18","modified":1497238070341},{"_id":"themes/landfarz/layout/_widget/category.ejs","hash":"c163a146b0f963f257ddcc244f413bef281fe0a0","modified":1497238070341},{"_id":"themes/landfarz/layout/_widget/search.ejs","hash":"93d4a690494dfa405024f23511846ea00d647be7","modified":1497238070342},{"_id":"themes/landfarz/layout/_widget/recent_posts.ejs","hash":"59f6f8362fa23a6215e3381151a59c2e2a5fd0d3","modified":1497238070341},{"_id":"themes/landfarz/layout/_widget/tag.ejs","hash":"6bf8214fedb8d6306e017e07ad67aab956496500","modified":1497238070342},{"_id":"themes/landfarz/layout/_widget/tagcloud.ejs","hash":"139e91b1e6abcc1e3883bcc03a9a1a7f1d891d7a","modified":1497238070342},{"_id":"themes/landfarz/source/css/style.styl","hash":"8e8458e78717c49c4ff278b741258d77301f6be4","modified":1497238070356},{"_id":"themes/landfarz/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1497238070359},{"_id":"themes/landfarz/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1497238070358},{"_id":"themes/landfarz/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1497238070359},{"_id":"themes/landfarz/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1497238070361},{"_id":"themes/landfarz/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1497238070360},{"_id":"themes/landfarz/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1497238070361},{"_id":"themes/landfarz/source/fancybox/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1497238070362},{"_id":"themes/landfarz/source/fancybox/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1497238070363},{"_id":"themes/landfarz/source/js/gallery.js","hash":"735a714e54f0ac229f292a90df3a1f882904f6c7","modified":1497238070364},{"_id":"themes/landfarz/source/js/jquery.imagesloaded.min.js","hash":"28ef4346743a60c896a9ae492a544c0854904350","modified":1497238070364},{"_id":"themes/landfarz/source/css/_base/utils.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497238070346},{"_id":"themes/landfarz/source/js/jquery.min.js","hash":"042dd055cd289215835a58507c9531f808e1648a","modified":1497238070366},{"_id":"themes/landfarz/layout/_partial/post/category.ejs","hash":"8bb3f6ee6296df5a0d527b30d5a46a2387b97cb7","modified":1497238070338},{"_id":"themes/landfarz/layout/_partial/post/title.ejs","hash":"7f93b310927d6238effdde15234d8cb242940893","modified":1497238070340},{"_id":"themes/landfarz/layout/_partial/post/share.ejs","hash":"991cf130c37f08c7e948772fb45587592b165b55","modified":1497238070339},{"_id":"themes/landfarz/layout/_partial/post/gallery.ejs","hash":"fc23ef9b5a412e05436f68ff47146b860d2d4225","modified":1497238070339},{"_id":"themes/landfarz/layout/_partial/post/tag.ejs","hash":"b21bbfb5479bd5968a610ba8bdb2bdf10d7a40e9","modified":1497238070340},{"_id":"themes/landfarz/source/css/_partial/archive.styl","hash":"b6fa84ea80bfbdb3a93f64c06a8c652e4242128e","modified":1497238070347},{"_id":"themes/landfarz/source/css/_partial/article.styl","hash":"ca982aa3f89b48077f8c2f977b805a3f1ff0b268","modified":1497238070348},{"_id":"themes/landfarz/source/css/_partial/comment.styl","hash":"85106e428b43e9eb488a71f55b9c4a9c33864d66","modified":1497238070348},{"_id":"themes/landfarz/source/css/_partial/footer.styl","hash":"bc58fb0d56a26ffa9891c80dd23d9add5cae5bdd","modified":1497238070348},{"_id":"themes/landfarz/source/css/_partial/header.styl","hash":"c9de2a1718e8612efa58fc52ff4012d01b96031d","modified":1497238070349},{"_id":"themes/landfarz/source/css/_partial/index.styl","hash":"8c52340a3bf3ce559502bcb9fdbd28a63598f1d6","modified":1497238070349},{"_id":"themes/landfarz/source/css/_partial/syntax.styl","hash":"e08fe789237bca9ea36b8fabaacb2e6070bdc639","modified":1497238070350},{"_id":"themes/landfarz/source/css/_partial/sidebar.styl","hash":"35bd524572c4164c9b550ab0c436742f691f4ec4","modified":1497238070349},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.eot","hash":"d775f599ff3f23be082e6a9604b4898718923a37","modified":1497238070350},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.woff","hash":"0612cddf2f835cceffccc88fd194f97367d0b024","modified":1497238070353},{"_id":"themes/landfarz/source/css/_base/layout.styl","hash":"b86dca5de36403f104e16321ccd758385b771134","modified":1497238070346},{"_id":"themes/landfarz/source/css/_base/variable.styl","hash":"0833485db79c55e5f8c1cb4dbe46529424923be8","modified":1497238070347},{"_id":"themes/landfarz/source/css/images/favicon.ico","hash":"b5b7667c7358e7300c4772d481e556b003716dab","modified":1497238070356},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.ttf","hash":"a9468f6a1fe965fbcaf5a1bd6c11705e2fc5f84c","modified":1497238070352},{"_id":"themes/landfarz/source/css/font/fontawesome-webfont.svg","hash":"ff51bbb11dfe58345f41cead2c425d6e8be28176","modified":1497238070351},{"_id":"themes/landfarz/source/css/images/body.jpg","hash":"eeecad49947335286ed22fdf942fa99da32b41ca","modified":1497238070355}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"AngularJS遇到的问题","date":"2016-10-05T08:58:40.000Z","_content":"### transclude\n---\n    嵌入的意思,也就是说你是否需要将你的指令（内部）的元素嵌入到你的（模板）中去，默认为false。\n    如果你需要的话，那么就需要将transclude设置为true。\n    如果将这个值设置为true的话，就要配合angular的ng-transclude指令来进行使用，\n\n---\n### 代码实现\n---\n    1.html中的代码\n    <!--  指令a-transclude 内部含有元素-->\n    <breadcrumb>指令（内部）内容</breadcrumb>\n---\n    2.js中的代码\n    myApp.directive('breadcrumb', ['$parse', function($parse) {\n        return {\n            templateUrl: 'tmpls/breadcrumb.html',\n            transclude:true\n        }\n    }]);\n\n---\n\n    3.tmpls/breadcrumb.html模板中的代码\n    <ol>\n        <li>\n            <a href=\"#\" ng-transclude>模板1</a>\n            <a href=\"#\">模板2</a>\n        </li>\n    </ol>\n    模板由两部分组成，一部分是含有ng-transclude指令的，一部分是不含有这个指令的\n---\n### ng-if 跟 ng-show/hide 的区别\n---\n    1. ng-if 在后面表达式为 true 的时候才创建这个 dom 节点。\n    ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。\n---\n    2. ng-if 会（隐式地）产生新作用域。\n     ng-switch 、 ng-include 等会动态创建一块界面的也是如此。\n     这样会导致，在 ng-if 中用基本变量绑定 ng-model ，\n     并在外层 div 中把此 model 绑定给另一个显示区域，\n     内层改变时，外层不会同步改变，因为此时已经是两个变量了。\n---\n    <p>{{name}}</p>\n    <div ng-if=\"true\">\n        <input type=\"text\" ng-model=\"name\">\n    </div>\n    ng-show 不存在此问题，因为它不自带一级作用域。\n---\n    避免这类问题出现的办法是，始终将页面中的元素绑定到对象的属性（data.x）\n    而不是直接绑定到基本变量（x）上。\n---","source":"_posts/AngularJS遇到的问题.md","raw":"---\ntitle: AngularJS遇到的问题\ndate: 2016-10-5 16:58:40\ntags:\n---\n### transclude\n---\n    嵌入的意思,也就是说你是否需要将你的指令（内部）的元素嵌入到你的（模板）中去，默认为false。\n    如果你需要的话，那么就需要将transclude设置为true。\n    如果将这个值设置为true的话，就要配合angular的ng-transclude指令来进行使用，\n\n---\n### 代码实现\n---\n    1.html中的代码\n    <!--  指令a-transclude 内部含有元素-->\n    <breadcrumb>指令（内部）内容</breadcrumb>\n---\n    2.js中的代码\n    myApp.directive('breadcrumb', ['$parse', function($parse) {\n        return {\n            templateUrl: 'tmpls/breadcrumb.html',\n            transclude:true\n        }\n    }]);\n\n---\n\n    3.tmpls/breadcrumb.html模板中的代码\n    <ol>\n        <li>\n            <a href=\"#\" ng-transclude>模板1</a>\n            <a href=\"#\">模板2</a>\n        </li>\n    </ol>\n    模板由两部分组成，一部分是含有ng-transclude指令的，一部分是不含有这个指令的\n---\n### ng-if 跟 ng-show/hide 的区别\n---\n    1. ng-if 在后面表达式为 true 的时候才创建这个 dom 节点。\n    ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。\n---\n    2. ng-if 会（隐式地）产生新作用域。\n     ng-switch 、 ng-include 等会动态创建一块界面的也是如此。\n     这样会导致，在 ng-if 中用基本变量绑定 ng-model ，\n     并在外层 div 中把此 model 绑定给另一个显示区域，\n     内层改变时，外层不会同步改变，因为此时已经是两个变量了。\n---\n    <p>{{name}}</p>\n    <div ng-if=\"true\">\n        <input type=\"text\" ng-model=\"name\">\n    </div>\n    ng-show 不存在此问题，因为它不自带一级作用域。\n---\n    避免这类问题出现的办法是，始终将页面中的元素绑定到对象的属性（data.x）\n    而不是直接绑定到基本变量（x）上。\n---","slug":"AngularJS遇到的问题","published":1,"updated":"2017-06-12T03:27:50.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4300004wusy65e9vef","content":"<h3 id=\"transclude\"><a href=\"#transclude\" class=\"headerlink\" title=\"transclude\"></a>transclude</h3><hr>\n<pre><code>嵌入的意思,也就是说你是否需要将你的指令（内部）的元素嵌入到你的（模板）中去，默认为false。\n如果你需要的话，那么就需要将transclude设置为true。\n如果将这个值设置为true的话，就要配合angular的ng-transclude指令来进行使用，\n</code></pre><hr>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<pre><code>1.html中的代码\n&lt;!--  指令a-transclude 内部含有元素--&gt;\n&lt;breadcrumb&gt;指令（内部）内容&lt;/breadcrumb&gt;\n</code></pre><hr>\n<pre><code>2.js中的代码\nmyApp.directive(&apos;breadcrumb&apos;, [&apos;$parse&apos;, function($parse) {\n    return {\n        templateUrl: &apos;tmpls/breadcrumb.html&apos;,\n        transclude:true\n    }\n}]);\n</code></pre><hr>\n<pre><code>3.tmpls/breadcrumb.html模板中的代码\n&lt;ol&gt;\n    &lt;li&gt;\n        &lt;a href=&quot;#&quot; ng-transclude&gt;模板1&lt;/a&gt;\n        &lt;a href=&quot;#&quot;&gt;模板2&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ol&gt;\n模板由两部分组成，一部分是含有ng-transclude指令的，一部分是不含有这个指令的\n</code></pre><hr>\n<h3 id=\"ng-if-跟-ng-show-hide-的区别\"><a href=\"#ng-if-跟-ng-show-hide-的区别\" class=\"headerlink\" title=\"ng-if 跟 ng-show/hide 的区别\"></a>ng-if 跟 ng-show/hide 的区别</h3><hr>\n<pre><code>1. ng-if 在后面表达式为 true 的时候才创建这个 dom 节点。\nng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。\n</code></pre><hr>\n<pre><code>2. ng-if 会（隐式地）产生新作用域。\n ng-switch 、 ng-include 等会动态创建一块界面的也是如此。\n 这样会导致，在 ng-if 中用基本变量绑定 ng-model ，\n 并在外层 div 中把此 model 绑定给另一个显示区域，\n 内层改变时，外层不会同步改变，因为此时已经是两个变量了。\n</code></pre><hr>\n<pre><code>&lt;p&gt;{{name}}&lt;/p&gt;\n&lt;div ng-if=&quot;true&quot;&gt;\n    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;\n&lt;/div&gt;\nng-show 不存在此问题，因为它不自带一级作用域。\n</code></pre><hr>\n<pre><code>避免这类问题出现的办法是，始终将页面中的元素绑定到对象的属性（data.x）\n而不是直接绑定到基本变量（x）上。\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"transclude\"><a href=\"#transclude\" class=\"headerlink\" title=\"transclude\"></a>transclude</h3><hr>\n<pre><code>嵌入的意思,也就是说你是否需要将你的指令（内部）的元素嵌入到你的（模板）中去，默认为false。\n如果你需要的话，那么就需要将transclude设置为true。\n如果将这个值设置为true的话，就要配合angular的ng-transclude指令来进行使用，\n</code></pre><hr>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<pre><code>1.html中的代码\n&lt;!--  指令a-transclude 内部含有元素--&gt;\n&lt;breadcrumb&gt;指令（内部）内容&lt;/breadcrumb&gt;\n</code></pre><hr>\n<pre><code>2.js中的代码\nmyApp.directive(&apos;breadcrumb&apos;, [&apos;$parse&apos;, function($parse) {\n    return {\n        templateUrl: &apos;tmpls/breadcrumb.html&apos;,\n        transclude:true\n    }\n}]);\n</code></pre><hr>\n<pre><code>3.tmpls/breadcrumb.html模板中的代码\n&lt;ol&gt;\n    &lt;li&gt;\n        &lt;a href=&quot;#&quot; ng-transclude&gt;模板1&lt;/a&gt;\n        &lt;a href=&quot;#&quot;&gt;模板2&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ol&gt;\n模板由两部分组成，一部分是含有ng-transclude指令的，一部分是不含有这个指令的\n</code></pre><hr>\n<h3 id=\"ng-if-跟-ng-show-hide-的区别\"><a href=\"#ng-if-跟-ng-show-hide-的区别\" class=\"headerlink\" title=\"ng-if 跟 ng-show/hide 的区别\"></a>ng-if 跟 ng-show/hide 的区别</h3><hr>\n<pre><code>1. ng-if 在后面表达式为 true 的时候才创建这个 dom 节点。\nng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。\n</code></pre><hr>\n<pre><code>2. ng-if 会（隐式地）产生新作用域。\n ng-switch 、 ng-include 等会动态创建一块界面的也是如此。\n 这样会导致，在 ng-if 中用基本变量绑定 ng-model ，\n 并在外层 div 中把此 model 绑定给另一个显示区域，\n 内层改变时，外层不会同步改变，因为此时已经是两个变量了。\n</code></pre><hr>\n<pre><code>&lt;p&gt;{{name}}&lt;/p&gt;\n&lt;div ng-if=&quot;true&quot;&gt;\n    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;\n&lt;/div&gt;\nng-show 不存在此问题，因为它不自带一级作用域。\n</code></pre><hr>\n<pre><code>避免这类问题出现的办法是，始终将页面中的元素绑定到对象的属性（data.x）\n而不是直接绑定到基本变量（x）上。\n</code></pre><hr>\n"},{"title":"Angular路由","date":"2016-10-11T04:48:22.000Z","_content":"    1. 什么是routing（路由）\n        设置页面不同于控制页面，登录页面不同于账号信息页面。\n        （一个应用很多功能不同的页面）\n---\n    2. 安装\n        使用angular的路由功能需要安装routing模块......（引入angular-route.js就可以了）\n---\n    3. 定义\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {});\n---\n    4. when()\n        when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。\n        一般main route经常使用“/”来表示，也可以定义URL参数，\n        在controller里面就使用$routeParams获取url参数。\n---\n    5. templateUrl: 表示路由跳转的view模板\n        controller: 控制器\n\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {\n        $routeProvider\n            .when('/', {\n              templateUrl: 'views/main.html',\n              controller: 'MainCtrl'\n            })\n            .when('/day/:id', {\n              templateUrl: 'views/day.html',\n              controller: 'DayCtrl'\n            })\n---\n    6. otherwise()\n        otherwise()定义了当应用找不到指定路由的时候跳转的路由\n\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {\n         $routeProvider\n            .when('/', {\n              templateUrl: 'views/main.html',\n              controller: 'MainCtrl'\n            })\n            .when('/day/:id', {\n              templateUrl: 'views/day.html',\n              controller: 'DayCtrl'\n            })\n            .otherwise({\n              redirectTo: '/'\n            });\n        })\n---\n    7. 使用\n        定义好了路由需要怎么使用呢?\n        我们要告诉angular页面的哪一个部分是我们希望转换的，\n        这需要使用到ng-view指令\\\n        <div class=\"header\">My page</div>\n        <div ng-view></div>\n        <span class=\"footer\">A footer</span>\n        这样就只有<div ng-view></div>会被更新， header/footer都始终保持不变\n---\n\n","source":"_posts/Angular路由.md","raw":"---\ntitle: Angular路由\ndate: 2016-10-11 12:48:22\ntags:\n---\n    1. 什么是routing（路由）\n        设置页面不同于控制页面，登录页面不同于账号信息页面。\n        （一个应用很多功能不同的页面）\n---\n    2. 安装\n        使用angular的路由功能需要安装routing模块......（引入angular-route.js就可以了）\n---\n    3. 定义\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {});\n---\n    4. when()\n        when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。\n        一般main route经常使用“/”来表示，也可以定义URL参数，\n        在controller里面就使用$routeParams获取url参数。\n---\n    5. templateUrl: 表示路由跳转的view模板\n        controller: 控制器\n\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {\n        $routeProvider\n            .when('/', {\n              templateUrl: 'views/main.html',\n              controller: 'MainCtrl'\n            })\n            .when('/day/:id', {\n              templateUrl: 'views/day.html',\n              controller: 'DayCtrl'\n            })\n---\n    6. otherwise()\n        otherwise()定义了当应用找不到指定路由的时候跳转的路由\n\n        angular.module('myApp', ['ngRoute'])\n        .config(function($routeProvider) {\n         $routeProvider\n            .when('/', {\n              templateUrl: 'views/main.html',\n              controller: 'MainCtrl'\n            })\n            .when('/day/:id', {\n              templateUrl: 'views/day.html',\n              controller: 'DayCtrl'\n            })\n            .otherwise({\n              redirectTo: '/'\n            });\n        })\n---\n    7. 使用\n        定义好了路由需要怎么使用呢?\n        我们要告诉angular页面的哪一个部分是我们希望转换的，\n        这需要使用到ng-view指令\\\n        <div class=\"header\">My page</div>\n        <div ng-view></div>\n        <span class=\"footer\">A footer</span>\n        这样就只有<div ng-view></div>会被更新， header/footer都始终保持不变\n---\n\n","slug":"Angular路由","published":1,"updated":"2017-06-12T03:27:50.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4a00014wusy6vj64pl","content":"<pre><code>1. 什么是routing（路由）\n    设置页面不同于控制页面，登录页面不同于账号信息页面。\n    （一个应用很多功能不同的页面）\n</code></pre><hr>\n<pre><code>2. 安装\n    使用angular的路由功能需要安装routing模块......（引入angular-route.js就可以了）\n</code></pre><hr>\n<pre><code>3. 定义\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {});\n</code></pre><hr>\n<pre><code>4. when()\n    when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。\n    一般main route经常使用“/”来表示，也可以定义URL参数，\n    在controller里面就使用$routeParams获取url参数。\n</code></pre><hr>\n<pre><code>5. templateUrl: 表示路由跳转的view模板\n    controller: 控制器\n\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {\n    $routeProvider\n        .when(&apos;/&apos;, {\n          templateUrl: &apos;views/main.html&apos;,\n          controller: &apos;MainCtrl&apos;\n        })\n        .when(&apos;/day/:id&apos;, {\n          templateUrl: &apos;views/day.html&apos;,\n          controller: &apos;DayCtrl&apos;\n        })\n</code></pre><hr>\n<pre><code>6. otherwise()\n    otherwise()定义了当应用找不到指定路由的时候跳转的路由\n\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {\n     $routeProvider\n        .when(&apos;/&apos;, {\n          templateUrl: &apos;views/main.html&apos;,\n          controller: &apos;MainCtrl&apos;\n        })\n        .when(&apos;/day/:id&apos;, {\n          templateUrl: &apos;views/day.html&apos;,\n          controller: &apos;DayCtrl&apos;\n        })\n        .otherwise({\n          redirectTo: &apos;/&apos;\n        });\n    })\n</code></pre><hr>\n<pre><code>7. 使用\n    定义好了路由需要怎么使用呢?\n    我们要告诉angular页面的哪一个部分是我们希望转换的，\n    这需要使用到ng-view指令\\\n    &lt;div class=&quot;header&quot;&gt;My page&lt;/div&gt;\n    &lt;div ng-view&gt;&lt;/div&gt;\n    &lt;span class=&quot;footer&quot;&gt;A footer&lt;/span&gt;\n    这样就只有&lt;div ng-view&gt;&lt;/div&gt;会被更新， header/footer都始终保持不变\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>1. 什么是routing（路由）\n    设置页面不同于控制页面，登录页面不同于账号信息页面。\n    （一个应用很多功能不同的页面）\n</code></pre><hr>\n<pre><code>2. 安装\n    使用angular的路由功能需要安装routing模块......（引入angular-route.js就可以了）\n</code></pre><hr>\n<pre><code>3. 定义\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {});\n</code></pre><hr>\n<pre><code>4. when()\n    when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。\n    一般main route经常使用“/”来表示，也可以定义URL参数，\n    在controller里面就使用$routeParams获取url参数。\n</code></pre><hr>\n<pre><code>5. templateUrl: 表示路由跳转的view模板\n    controller: 控制器\n\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {\n    $routeProvider\n        .when(&apos;/&apos;, {\n          templateUrl: &apos;views/main.html&apos;,\n          controller: &apos;MainCtrl&apos;\n        })\n        .when(&apos;/day/:id&apos;, {\n          templateUrl: &apos;views/day.html&apos;,\n          controller: &apos;DayCtrl&apos;\n        })\n</code></pre><hr>\n<pre><code>6. otherwise()\n    otherwise()定义了当应用找不到指定路由的时候跳转的路由\n\n    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])\n    .config(function($routeProvider) {\n     $routeProvider\n        .when(&apos;/&apos;, {\n          templateUrl: &apos;views/main.html&apos;,\n          controller: &apos;MainCtrl&apos;\n        })\n        .when(&apos;/day/:id&apos;, {\n          templateUrl: &apos;views/day.html&apos;,\n          controller: &apos;DayCtrl&apos;\n        })\n        .otherwise({\n          redirectTo: &apos;/&apos;\n        });\n    })\n</code></pre><hr>\n<pre><code>7. 使用\n    定义好了路由需要怎么使用呢?\n    我们要告诉angular页面的哪一个部分是我们希望转换的，\n    这需要使用到ng-view指令\\\n    &lt;div class=&quot;header&quot;&gt;My page&lt;/div&gt;\n    &lt;div ng-view&gt;&lt;/div&gt;\n    &lt;span class=&quot;footer&quot;&gt;A footer&lt;/span&gt;\n    这样就只有&lt;div ng-view&gt;&lt;/div&gt;会被更新， header/footer都始终保持不变\n</code></pre><hr>\n"},{"title":"CSS3","date":"2016-09-10T09:02:24.000Z","_content":"\t1. 文本垂直水平居中问题\n\t\t设置\n\t\tline-height\n\t\ttext-alignt:center\n---\n\t2. 块状行内对齐\n\t\tvertical-align: middle\n---\n\t3.动画\n    https://songhuajian.github.io/SHJ/\n---","source":"_posts/CSS3.md","raw":"---\ntitle: CSS3\ndate: 2016-09-10 17:02:24\ntags:\n---\n\t1. 文本垂直水平居中问题\n\t\t设置\n\t\tline-height\n\t\ttext-alignt:center\n---\n\t2. 块状行内对齐\n\t\tvertical-align: middle\n---\n\t3.动画\n    https://songhuajian.github.io/SHJ/\n---","slug":"CSS3","published":1,"updated":"2017-06-12T03:27:50.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4d00024wusfdcky2ep","content":"<pre><code>1. 文本垂直水平居中问题\n    设置\n    line-height\n    text-alignt:center\n</code></pre><hr>\n<pre><code>2. 块状行内对齐\n    vertical-align: middle\n</code></pre><hr>\n<pre><code>3.动画\nhttps://songhuajian.github.io/SHJ/\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>1. 文本垂直水平居中问题\n    设置\n    line-height\n    text-alignt:center\n</code></pre><hr>\n<pre><code>2. 块状行内对齐\n    vertical-align: middle\n</code></pre><hr>\n<pre><code>3.动画\nhttps://songhuajian.github.io/SHJ/\n</code></pre><hr>\n"},{"title":"Javascript闭包","date":"2016-09-20T08:56:48.000Z","_content":"---\n本文大部分出自阮一峰\n---\n    1. 变量的作用域\n        要理解闭包，首先必须理解Javascript特殊的变量作用域。\n        变量的作用域无非就是两种：全局变量和局部变量。\n        Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n        var n=999;\n        function f1(){\n            alert(n);\n        }\n        f1(); // 999\n        另一方面，在函数外部自然无法读取函数内的局部变量。\n        function f1(){\n            var n=999;\n            }\n        alert(n); // error\n        这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。\n        如果不用的话，你实际上声明了一个全局变量！\n        function f1(){\n            n=999;\n            }\n        f1();\n        alert(n); // 999\n---\n    2. 如何从外部读取局部变量？\n        出于种种原因，我们有时候需要得到函数内的局部变量。\n        但是，前面已经说过了，正常情况下，这是办不到的，\n        只有通过变通方法才能实现。\n        那就是在函数的内部，再定义一个函数。\n        function f1(){\n           var n=999;\n           function f2(){\n               alert(n); // 999\n           }\n        }\n        在上面的代码中，函数f2就被包括在函数f1内部，\n        这时f1内部的所有局部变量，对f2都是可见的。\n        但是反过来就不行，f2内部的局部变量，对f1就是不可见的。\n        这就是Javascript语言特有的\"链式作用域\"\n        结构（chain scope），\n        子对象会一级一级地向上寻找所有父对象的变量。\n        所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n        既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，\n        我们不就可以在f1外部读取它的内部变量了吗！\n        function f1(){\n            var n=999;\n            function f2(){\n                alert(n); \n            }\n            return f2;\n        }\n        var result=f1();\n        result(); // 999\n---\n    3. 闭包的概念\n        上一节代码中的f2函数，就是闭包。\n        各种专业文献上的\"闭包\"（closure）定义非常抽象，很难看懂。\n        我的理解是，闭包就是能够读取其他函数内部变量的函数。\n        由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，\n        因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n        所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁\n---\n    4.闭包的用途\n        闭包可以用在许多地方。它的最大用处有两个，\n        一个是前面提到的可以读取函数内部的变量，\n        另一个就是让这些变量的值始终保持在内存中。\n        怎么来理解这句话呢？请看下面的代码。\n        function f1(){\n            var n=999;\n            nAdd=function(){n+=1}\n            function f2(){\n                alert(n);\n            }\n            return f2;\n        }\n        var result=f1();\n        result(); // 999\n        nAdd();\n        result(); // 1000在这段代码中，result实际上就是闭包f2函数。\n        它一共运行了两次，第一次的值是999，第二次的值是1000。\n        这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n        为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，\n        这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，\n        不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n        这段代码中另一个值得注意的地方，就是\"nAdd=function(){n+=1}\"这一行，\n        首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。\n        其次，nAdd的值是一个匿名函数（anonymous function），\n        而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，\n        可以在函数外部对函数内部的局部变量进行操作。\n---\n    5. 使用闭包的注意点\n        1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，\n        所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。\n        解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n        2）闭包会在父函数外部，改变父函数内部变量的值。\n        所以，如果你把父函数当作对象（object）使用，\n        把闭包当作它的公用方法（Public Method），\n        把内部变量当作它的私有属性（private value），这时一定要小心，\n        不要随便改变父函数内部变量的值。\n---\n    6. 思考题\n        如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。\n        代码片段一。\n        var name = \"The Window\";\n        var object = {\n            name : \"My Object\",\n            getNameFunc : function(){\n                return function(){\n                    return this.name;\n                };\n            }\n        };\n        alert(object.getNameFunc()());\n        弹出The Window\n\n    代码片段二。\n        var name = \"The Window\";\n        var object = {\n            name : \"My Object\",\n            getNameFunc : function(){\n                var that = this;\n                return function(){\n                    return that.name;\n                };\n            }\n        };\n        alert(object.getNameFunc()());\n        很明显 弹出 My Object","source":"_posts/Javascript闭包.md","raw":"---\ntitle: Javascript闭包\ndate: 2016-09-20 16:56:48\ntags:\n---\n---\n本文大部分出自阮一峰\n---\n    1. 变量的作用域\n        要理解闭包，首先必须理解Javascript特殊的变量作用域。\n        变量的作用域无非就是两种：全局变量和局部变量。\n        Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n        var n=999;\n        function f1(){\n            alert(n);\n        }\n        f1(); // 999\n        另一方面，在函数外部自然无法读取函数内的局部变量。\n        function f1(){\n            var n=999;\n            }\n        alert(n); // error\n        这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。\n        如果不用的话，你实际上声明了一个全局变量！\n        function f1(){\n            n=999;\n            }\n        f1();\n        alert(n); // 999\n---\n    2. 如何从外部读取局部变量？\n        出于种种原因，我们有时候需要得到函数内的局部变量。\n        但是，前面已经说过了，正常情况下，这是办不到的，\n        只有通过变通方法才能实现。\n        那就是在函数的内部，再定义一个函数。\n        function f1(){\n           var n=999;\n           function f2(){\n               alert(n); // 999\n           }\n        }\n        在上面的代码中，函数f2就被包括在函数f1内部，\n        这时f1内部的所有局部变量，对f2都是可见的。\n        但是反过来就不行，f2内部的局部变量，对f1就是不可见的。\n        这就是Javascript语言特有的\"链式作用域\"\n        结构（chain scope），\n        子对象会一级一级地向上寻找所有父对象的变量。\n        所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n        既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，\n        我们不就可以在f1外部读取它的内部变量了吗！\n        function f1(){\n            var n=999;\n            function f2(){\n                alert(n); \n            }\n            return f2;\n        }\n        var result=f1();\n        result(); // 999\n---\n    3. 闭包的概念\n        上一节代码中的f2函数，就是闭包。\n        各种专业文献上的\"闭包\"（closure）定义非常抽象，很难看懂。\n        我的理解是，闭包就是能够读取其他函数内部变量的函数。\n        由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，\n        因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n        所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁\n---\n    4.闭包的用途\n        闭包可以用在许多地方。它的最大用处有两个，\n        一个是前面提到的可以读取函数内部的变量，\n        另一个就是让这些变量的值始终保持在内存中。\n        怎么来理解这句话呢？请看下面的代码。\n        function f1(){\n            var n=999;\n            nAdd=function(){n+=1}\n            function f2(){\n                alert(n);\n            }\n            return f2;\n        }\n        var result=f1();\n        result(); // 999\n        nAdd();\n        result(); // 1000在这段代码中，result实际上就是闭包f2函数。\n        它一共运行了两次，第一次的值是999，第二次的值是1000。\n        这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n        为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，\n        这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，\n        不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n        这段代码中另一个值得注意的地方，就是\"nAdd=function(){n+=1}\"这一行，\n        首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。\n        其次，nAdd的值是一个匿名函数（anonymous function），\n        而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，\n        可以在函数外部对函数内部的局部变量进行操作。\n---\n    5. 使用闭包的注意点\n        1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，\n        所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。\n        解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n        2）闭包会在父函数外部，改变父函数内部变量的值。\n        所以，如果你把父函数当作对象（object）使用，\n        把闭包当作它的公用方法（Public Method），\n        把内部变量当作它的私有属性（private value），这时一定要小心，\n        不要随便改变父函数内部变量的值。\n---\n    6. 思考题\n        如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。\n        代码片段一。\n        var name = \"The Window\";\n        var object = {\n            name : \"My Object\",\n            getNameFunc : function(){\n                return function(){\n                    return this.name;\n                };\n            }\n        };\n        alert(object.getNameFunc()());\n        弹出The Window\n\n    代码片段二。\n        var name = \"The Window\";\n        var object = {\n            name : \"My Object\",\n            getNameFunc : function(){\n                var that = this;\n                return function(){\n                    return that.name;\n                };\n            }\n        };\n        alert(object.getNameFunc()());\n        很明显 弹出 My Object","slug":"Javascript闭包","published":1,"updated":"2017-06-12T03:27:50.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4f00034wus47wmox1a","content":"<hr>\n<h2 id=\"本文大部分出自阮一峰\"><a href=\"#本文大部分出自阮一峰\" class=\"headerlink\" title=\"本文大部分出自阮一峰\"></a>本文大部分出自阮一峰</h2><pre><code>1. 变量的作用域\n    要理解闭包，首先必须理解Javascript特殊的变量作用域。\n    变量的作用域无非就是两种：全局变量和局部变量。\n    Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n    var n=999;\n    function f1(){\n        alert(n);\n    }\n    f1(); // 999\n    另一方面，在函数外部自然无法读取函数内的局部变量。\n    function f1(){\n        var n=999;\n        }\n    alert(n); // error\n    这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。\n    如果不用的话，你实际上声明了一个全局变量！\n    function f1(){\n        n=999;\n        }\n    f1();\n    alert(n); // 999\n</code></pre><hr>\n<pre><code>2. 如何从外部读取局部变量？\n    出于种种原因，我们有时候需要得到函数内的局部变量。\n    但是，前面已经说过了，正常情况下，这是办不到的，\n    只有通过变通方法才能实现。\n    那就是在函数的内部，再定义一个函数。\n    function f1(){\n       var n=999;\n       function f2(){\n           alert(n); // 999\n       }\n    }\n    在上面的代码中，函数f2就被包括在函数f1内部，\n    这时f1内部的所有局部变量，对f2都是可见的。\n    但是反过来就不行，f2内部的局部变量，对f1就是不可见的。\n    这就是Javascript语言特有的&quot;链式作用域&quot;\n    结构（chain scope），\n    子对象会一级一级地向上寻找所有父对象的变量。\n    所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n    既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，\n    我们不就可以在f1外部读取它的内部变量了吗！\n    function f1(){\n        var n=999;\n        function f2(){\n            alert(n); \n        }\n        return f2;\n    }\n    var result=f1();\n    result(); // 999\n</code></pre><hr>\n<pre><code>3. 闭包的概念\n    上一节代码中的f2函数，就是闭包。\n    各种专业文献上的&quot;闭包&quot;（closure）定义非常抽象，很难看懂。\n    我的理解是，闭包就是能够读取其他函数内部变量的函数。\n    由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，\n    因此可以把闭包简单理解成&quot;定义在一个函数内部的函数&quot;。\n    所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁\n</code></pre><hr>\n<pre><code>4.闭包的用途\n    闭包可以用在许多地方。它的最大用处有两个，\n    一个是前面提到的可以读取函数内部的变量，\n    另一个就是让这些变量的值始终保持在内存中。\n    怎么来理解这句话呢？请看下面的代码。\n    function f1(){\n        var n=999;\n        nAdd=function(){n+=1}\n        function f2(){\n            alert(n);\n        }\n        return f2;\n    }\n    var result=f1();\n    result(); // 999\n    nAdd();\n    result(); // 1000在这段代码中，result实际上就是闭包f2函数。\n    它一共运行了两次，第一次的值是999，第二次的值是1000。\n    这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n    为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，\n    这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，\n    不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n    这段代码中另一个值得注意的地方，就是&quot;nAdd=function(){n+=1}&quot;这一行，\n    首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。\n    其次，nAdd的值是一个匿名函数（anonymous function），\n    而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，\n    可以在函数外部对函数内部的局部变量进行操作。\n</code></pre><hr>\n<pre><code>5. 使用闭包的注意点\n    1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，\n    所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。\n    解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n    2）闭包会在父函数外部，改变父函数内部变量的值。\n    所以，如果你把父函数当作对象（object）使用，\n    把闭包当作它的公用方法（Public Method），\n    把内部变量当作它的私有属性（private value），这时一定要小心，\n    不要随便改变父函数内部变量的值。\n</code></pre><hr>\n<pre><code>6. 思考题\n    如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。\n    代码片段一。\n    var name = &quot;The Window&quot;;\n    var object = {\n        name : &quot;My Object&quot;,\n        getNameFunc : function(){\n            return function(){\n                return this.name;\n            };\n        }\n    };\n    alert(object.getNameFunc()());\n    弹出The Window\n\n代码片段二。\n    var name = &quot;The Window&quot;;\n    var object = {\n        name : &quot;My Object&quot;,\n        getNameFunc : function(){\n            var that = this;\n            return function(){\n                return that.name;\n            };\n        }\n    };\n    alert(object.getNameFunc()());\n    很明显 弹出 My Object\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"本文大部分出自阮一峰\"><a href=\"#本文大部分出自阮一峰\" class=\"headerlink\" title=\"本文大部分出自阮一峰\"></a>本文大部分出自阮一峰</h2><pre><code>1. 变量的作用域\n    要理解闭包，首先必须理解Javascript特殊的变量作用域。\n    变量的作用域无非就是两种：全局变量和局部变量。\n    Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n    var n=999;\n    function f1(){\n        alert(n);\n    }\n    f1(); // 999\n    另一方面，在函数外部自然无法读取函数内的局部变量。\n    function f1(){\n        var n=999;\n        }\n    alert(n); // error\n    这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。\n    如果不用的话，你实际上声明了一个全局变量！\n    function f1(){\n        n=999;\n        }\n    f1();\n    alert(n); // 999\n</code></pre><hr>\n<pre><code>2. 如何从外部读取局部变量？\n    出于种种原因，我们有时候需要得到函数内的局部变量。\n    但是，前面已经说过了，正常情况下，这是办不到的，\n    只有通过变通方法才能实现。\n    那就是在函数的内部，再定义一个函数。\n    function f1(){\n       var n=999;\n       function f2(){\n           alert(n); // 999\n       }\n    }\n    在上面的代码中，函数f2就被包括在函数f1内部，\n    这时f1内部的所有局部变量，对f2都是可见的。\n    但是反过来就不行，f2内部的局部变量，对f1就是不可见的。\n    这就是Javascript语言特有的&quot;链式作用域&quot;\n    结构（chain scope），\n    子对象会一级一级地向上寻找所有父对象的变量。\n    所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n    既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，\n    我们不就可以在f1外部读取它的内部变量了吗！\n    function f1(){\n        var n=999;\n        function f2(){\n            alert(n); \n        }\n        return f2;\n    }\n    var result=f1();\n    result(); // 999\n</code></pre><hr>\n<pre><code>3. 闭包的概念\n    上一节代码中的f2函数，就是闭包。\n    各种专业文献上的&quot;闭包&quot;（closure）定义非常抽象，很难看懂。\n    我的理解是，闭包就是能够读取其他函数内部变量的函数。\n    由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，\n    因此可以把闭包简单理解成&quot;定义在一个函数内部的函数&quot;。\n    所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁\n</code></pre><hr>\n<pre><code>4.闭包的用途\n    闭包可以用在许多地方。它的最大用处有两个，\n    一个是前面提到的可以读取函数内部的变量，\n    另一个就是让这些变量的值始终保持在内存中。\n    怎么来理解这句话呢？请看下面的代码。\n    function f1(){\n        var n=999;\n        nAdd=function(){n+=1}\n        function f2(){\n            alert(n);\n        }\n        return f2;\n    }\n    var result=f1();\n    result(); // 999\n    nAdd();\n    result(); // 1000在这段代码中，result实际上就是闭包f2函数。\n    它一共运行了两次，第一次的值是999，第二次的值是1000。\n    这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n    为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，\n    这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，\n    不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n    这段代码中另一个值得注意的地方，就是&quot;nAdd=function(){n+=1}&quot;这一行，\n    首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。\n    其次，nAdd的值是一个匿名函数（anonymous function），\n    而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，\n    可以在函数外部对函数内部的局部变量进行操作。\n</code></pre><hr>\n<pre><code>5. 使用闭包的注意点\n    1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，\n    所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。\n    解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n    2）闭包会在父函数外部，改变父函数内部变量的值。\n    所以，如果你把父函数当作对象（object）使用，\n    把闭包当作它的公用方法（Public Method），\n    把内部变量当作它的私有属性（private value），这时一定要小心，\n    不要随便改变父函数内部变量的值。\n</code></pre><hr>\n<pre><code>6. 思考题\n    如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。\n    代码片段一。\n    var name = &quot;The Window&quot;;\n    var object = {\n        name : &quot;My Object&quot;,\n        getNameFunc : function(){\n            return function(){\n                return this.name;\n            };\n        }\n    };\n    alert(object.getNameFunc()());\n    弹出The Window\n\n代码片段二。\n    var name = &quot;The Window&quot;;\n    var object = {\n        name : &quot;My Object&quot;,\n        getNameFunc : function(){\n            var that = this;\n            return function(){\n                return that.name;\n            };\n        }\n    };\n    alert(object.getNameFunc()());\n    很明显 弹出 My Object\n</code></pre>"},{"title":"Javascript面向对象编程","date":"2016-09-25T08:57:38.000Z","_content":"---\n---\n\t1. Javascript面向对象编程\n        Javascript不是一种真正的面向对象编程（OOP）语言，\n        语法中没有类的概念，却又是基于对象（object-based）的语言，\n        你遇到的所有东西几乎都是对象。\n        所以我们用构造函数的方法给一个函数加上属性和方法，成为一个对象。\n---\n\t2. 假定我们把Person看成一个对象，它有\"名字\"和\"颜色\"两个属性。\n        var Person = {\n            name : '',\n            age : ''\n        } \n        现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象\n                var Person1 = {}; // 创建一个空对象\n                Person1.name = \"张三\"; // 按照原型对象的属性赋值\n                Person1.age = \"33\";\n                var Person2 = {};\n                Person2.name = \"李四\";\n                Person2.age = \"44\";\n        最简单的封装，把两个属性封装在一个对象里面。\n        两个缺点，一是如果多生成几个实例，写起来就非常麻烦；\n        二是实例与原型之间，没有任何办法，可以看出有什么联系\n---\n\t3. 原始模式的改进\n        我们可以写一个函数，解决代码重复的问题。\n            function Person(name,age) {\n                return { \n                    name:name,\n                    age:age\n                    }\n                }\n        然后生成实例对象，就等于是在调用函数：\n        var Person1 = Person(\"张三\",\"33\");\n        var Person2 = Person(\"李四\",\"44\");\n        这种方法的问题依然是，Person1和Person2之间没有内在的联系，\n        不能反映出它们是同一个原型对象的实例。\n---\n    4. 构造函数模式\n        为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数\n        （Constructor）模式。\n        所谓\"构造函数\"，其实就是一个普通函数，但是内部使用了this变量。\n        对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n        比如，猫的原型对象现在可以这样写，\n        function Person(name,age){\n            this.name=name;\n            this.age=age;\n        }\n        我们现在就可以生成实例对象了。\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person(\"李四\",\"44\");\n        alert(Person1.name); // 张三\n        alert(Person1.age); // 33这时Person1和Person2会自动含有一个\n        constructor属性，指向它们的构造函数。\n        alert(Person1.constructor == Person); //true\n        alert(Person2.constructor == Person); //true\n        Javascript还提供了一个instanceof运算符，验证原型对象\n        与实例对象之间的关系。\n        alert(Person1 instanceof Person); //true\n        alert(Person2 instanceof Person); //true\n        构造函数模式的问题\n        构造函数方法很好用，但是存在一个浪费内存的问题。\n        请看，我们现在为Person对象添加一个不变的属性type（种类），\n        再添加一个方法eat（吃）。那么，原型对象Person就变成了下面这样：\n        function Person(name,age){\n            this.name = name;\n            this.age = age;\n            this.type = \"人\";\n            this.eat = function(){alert(\"吃饭\");};\n            }\n        还是采用同样的方法，生成实例：\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person (\"李四\",\"44\");\n        alert(Person1.type); // 人\n        Person1.eat(); // 吃饭\n        表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。\n        对于每一个实例对象，type属性和eat()方法都是一模一样的内容，\n        每一次生成一个实例，都必须为重复的内容，多占用一些内存。\n        这样既不环保，也缺乏效率。\n        alert(Person1.eat == Person2.eat); //false\n        能不能让type属性和eat()方法在内存中只生成一次，\n        然后所有实例都指向那个内存地址呢？回答是可以的。\n---\n    5. Prototype模式\n        Javascript规定，每一个构造函数都有一个prototype属性，\n        指向另一个对象。\n        这个对象的所有属性和方法，都会被构造函数的实例继承。\n        这意味着，我们可以把那些不变的属性和方法，\n        直接定义在prototype对象上。\n        function Person(name,age){\n            this.name = name;\n            this.age = age;\n        }\n        Person.prototype.type = \"人\";\n        Person.prototype.eat = function(){alert(\"吃饭\")};\n        然后，生成实例。\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person(\"李四\",\"44\");\n        alert(Person1.type); // 人\n        Person1.eat(); // 吃饭\n        这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，\n        因此就提高了运行效率。\n        alert(Person1.eat == Person2.eat); //true\n---\n    6. Prototype模式的验证方法\n    为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n        6.1 isPrototypeOf()\n            这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n            alert(Person.prototype.isPrototypeOf(Person1)); //true\n            alert(Person.prototype.isPrototypeOf(Person2)); //true\n        6.2 hasOwnProperty()\n            每个实例对象都有一个hasOwnProperty()方法，\n            用来判断某一个属性到底是本地属性，\n            还是继承自prototype对象的属性。\n            alert(Person1.hasOwnProperty(\"name\")); // true\n            alert(Person1.hasOwnProperty(\"type\")); // false\n        6.3 in运算符\n            in运算符可以用来判断，某个实例是否含有某个属性，\n            不管是不是本地属性。\n            alert(\"name\" in Person1); // true\n            alert(\"type\" in Person1); // true\n            in运算符还可以用来遍历某个对象的所有属性。\n            for(var prop in Person1) {\n             alert(\"Person1[\"+prop+\"]=\"+Person1[prop]); \n            }\n","source":"_posts/Javascript面向对象编程.md","raw":"---\ntitle: Javascript面向对象编程\ndate: 2016-9-25 16:57:38\ntags:\n---\n---\n---\n\t1. Javascript面向对象编程\n        Javascript不是一种真正的面向对象编程（OOP）语言，\n        语法中没有类的概念，却又是基于对象（object-based）的语言，\n        你遇到的所有东西几乎都是对象。\n        所以我们用构造函数的方法给一个函数加上属性和方法，成为一个对象。\n---\n\t2. 假定我们把Person看成一个对象，它有\"名字\"和\"颜色\"两个属性。\n        var Person = {\n            name : '',\n            age : ''\n        } \n        现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象\n                var Person1 = {}; // 创建一个空对象\n                Person1.name = \"张三\"; // 按照原型对象的属性赋值\n                Person1.age = \"33\";\n                var Person2 = {};\n                Person2.name = \"李四\";\n                Person2.age = \"44\";\n        最简单的封装，把两个属性封装在一个对象里面。\n        两个缺点，一是如果多生成几个实例，写起来就非常麻烦；\n        二是实例与原型之间，没有任何办法，可以看出有什么联系\n---\n\t3. 原始模式的改进\n        我们可以写一个函数，解决代码重复的问题。\n            function Person(name,age) {\n                return { \n                    name:name,\n                    age:age\n                    }\n                }\n        然后生成实例对象，就等于是在调用函数：\n        var Person1 = Person(\"张三\",\"33\");\n        var Person2 = Person(\"李四\",\"44\");\n        这种方法的问题依然是，Person1和Person2之间没有内在的联系，\n        不能反映出它们是同一个原型对象的实例。\n---\n    4. 构造函数模式\n        为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数\n        （Constructor）模式。\n        所谓\"构造函数\"，其实就是一个普通函数，但是内部使用了this变量。\n        对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n        比如，猫的原型对象现在可以这样写，\n        function Person(name,age){\n            this.name=name;\n            this.age=age;\n        }\n        我们现在就可以生成实例对象了。\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person(\"李四\",\"44\");\n        alert(Person1.name); // 张三\n        alert(Person1.age); // 33这时Person1和Person2会自动含有一个\n        constructor属性，指向它们的构造函数。\n        alert(Person1.constructor == Person); //true\n        alert(Person2.constructor == Person); //true\n        Javascript还提供了一个instanceof运算符，验证原型对象\n        与实例对象之间的关系。\n        alert(Person1 instanceof Person); //true\n        alert(Person2 instanceof Person); //true\n        构造函数模式的问题\n        构造函数方法很好用，但是存在一个浪费内存的问题。\n        请看，我们现在为Person对象添加一个不变的属性type（种类），\n        再添加一个方法eat（吃）。那么，原型对象Person就变成了下面这样：\n        function Person(name,age){\n            this.name = name;\n            this.age = age;\n            this.type = \"人\";\n            this.eat = function(){alert(\"吃饭\");};\n            }\n        还是采用同样的方法，生成实例：\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person (\"李四\",\"44\");\n        alert(Person1.type); // 人\n        Person1.eat(); // 吃饭\n        表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。\n        对于每一个实例对象，type属性和eat()方法都是一模一样的内容，\n        每一次生成一个实例，都必须为重复的内容，多占用一些内存。\n        这样既不环保，也缺乏效率。\n        alert(Person1.eat == Person2.eat); //false\n        能不能让type属性和eat()方法在内存中只生成一次，\n        然后所有实例都指向那个内存地址呢？回答是可以的。\n---\n    5. Prototype模式\n        Javascript规定，每一个构造函数都有一个prototype属性，\n        指向另一个对象。\n        这个对象的所有属性和方法，都会被构造函数的实例继承。\n        这意味着，我们可以把那些不变的属性和方法，\n        直接定义在prototype对象上。\n        function Person(name,age){\n            this.name = name;\n            this.age = age;\n        }\n        Person.prototype.type = \"人\";\n        Person.prototype.eat = function(){alert(\"吃饭\")};\n        然后，生成实例。\n        var Person1 = new Person(\"张三\",\"33\");\n        var Person2 = new Person(\"李四\",\"44\");\n        alert(Person1.type); // 人\n        Person1.eat(); // 吃饭\n        这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，\n        因此就提高了运行效率。\n        alert(Person1.eat == Person2.eat); //true\n---\n    6. Prototype模式的验证方法\n    为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n        6.1 isPrototypeOf()\n            这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n            alert(Person.prototype.isPrototypeOf(Person1)); //true\n            alert(Person.prototype.isPrototypeOf(Person2)); //true\n        6.2 hasOwnProperty()\n            每个实例对象都有一个hasOwnProperty()方法，\n            用来判断某一个属性到底是本地属性，\n            还是继承自prototype对象的属性。\n            alert(Person1.hasOwnProperty(\"name\")); // true\n            alert(Person1.hasOwnProperty(\"type\")); // false\n        6.3 in运算符\n            in运算符可以用来判断，某个实例是否含有某个属性，\n            不管是不是本地属性。\n            alert(\"name\" in Person1); // true\n            alert(\"type\" in Person1); // true\n            in运算符还可以用来遍历某个对象的所有属性。\n            for(var prop in Person1) {\n             alert(\"Person1[\"+prop+\"]=\"+Person1[prop]); \n            }\n","slug":"Javascript面向对象编程","published":1,"updated":"2017-06-12T03:27:50.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4i00044wuslqtmt1aa","content":"<h2 id=\"—\"><a href=\"#—\" class=\"headerlink\" title=\"—\"></a>—</h2><pre><code>1. Javascript面向对象编程\n    Javascript不是一种真正的面向对象编程（OOP）语言，\n    语法中没有类的概念，却又是基于对象（object-based）的语言，\n    你遇到的所有东西几乎都是对象。\n    所以我们用构造函数的方法给一个函数加上属性和方法，成为一个对象。\n</code></pre><hr>\n<pre><code>2. 假定我们把Person看成一个对象，它有&quot;名字&quot;和&quot;颜色&quot;两个属性。\n    var Person = {\n        name : &apos;&apos;,\n        age : &apos;&apos;\n    } \n    现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象\n            var Person1 = {}; // 创建一个空对象\n            Person1.name = &quot;张三&quot;; // 按照原型对象的属性赋值\n            Person1.age = &quot;33&quot;;\n            var Person2 = {};\n            Person2.name = &quot;李四&quot;;\n            Person2.age = &quot;44&quot;;\n    最简单的封装，把两个属性封装在一个对象里面。\n    两个缺点，一是如果多生成几个实例，写起来就非常麻烦；\n    二是实例与原型之间，没有任何办法，可以看出有什么联系\n</code></pre><hr>\n<pre><code>3. 原始模式的改进\n    我们可以写一个函数，解决代码重复的问题。\n        function Person(name,age) {\n            return { \n                name:name,\n                age:age\n                }\n            }\n    然后生成实例对象，就等于是在调用函数：\n    var Person1 = Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = Person(&quot;李四&quot;,&quot;44&quot;);\n    这种方法的问题依然是，Person1和Person2之间没有内在的联系，\n    不能反映出它们是同一个原型对象的实例。\n</code></pre><hr>\n<pre><code>4. 构造函数模式\n    为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数\n    （Constructor）模式。\n    所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。\n    对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n    比如，猫的原型对象现在可以这样写，\n    function Person(name,age){\n        this.name=name;\n        this.age=age;\n    }\n    我们现在就可以生成实例对象了。\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.name); // 张三\n    alert(Person1.age); // 33这时Person1和Person2会自动含有一个\n    constructor属性，指向它们的构造函数。\n    alert(Person1.constructor == Person); //true\n    alert(Person2.constructor == Person); //true\n    Javascript还提供了一个instanceof运算符，验证原型对象\n    与实例对象之间的关系。\n    alert(Person1 instanceof Person); //true\n    alert(Person2 instanceof Person); //true\n    构造函数模式的问题\n    构造函数方法很好用，但是存在一个浪费内存的问题。\n    请看，我们现在为Person对象添加一个不变的属性type（种类），\n    再添加一个方法eat（吃）。那么，原型对象Person就变成了下面这样：\n    function Person(name,age){\n        this.name = name;\n        this.age = age;\n        this.type = &quot;人&quot;;\n        this.eat = function(){alert(&quot;吃饭&quot;);};\n        }\n    还是采用同样的方法，生成实例：\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person (&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.type); // 人\n    Person1.eat(); // 吃饭\n    表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。\n    对于每一个实例对象，type属性和eat()方法都是一模一样的内容，\n    每一次生成一个实例，都必须为重复的内容，多占用一些内存。\n    这样既不环保，也缺乏效率。\n    alert(Person1.eat == Person2.eat); //false\n    能不能让type属性和eat()方法在内存中只生成一次，\n    然后所有实例都指向那个内存地址呢？回答是可以的。\n</code></pre><hr>\n<pre><code>5. Prototype模式\n    Javascript规定，每一个构造函数都有一个prototype属性，\n    指向另一个对象。\n    这个对象的所有属性和方法，都会被构造函数的实例继承。\n    这意味着，我们可以把那些不变的属性和方法，\n    直接定义在prototype对象上。\n    function Person(name,age){\n        this.name = name;\n        this.age = age;\n    }\n    Person.prototype.type = &quot;人&quot;;\n    Person.prototype.eat = function(){alert(&quot;吃饭&quot;)};\n    然后，生成实例。\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.type); // 人\n    Person1.eat(); // 吃饭\n    这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，\n    因此就提高了运行效率。\n    alert(Person1.eat == Person2.eat); //true\n</code></pre><hr>\n<pre><code>6. Prototype模式的验证方法\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n    6.1 isPrototypeOf()\n        这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n        alert(Person.prototype.isPrototypeOf(Person1)); //true\n        alert(Person.prototype.isPrototypeOf(Person2)); //true\n    6.2 hasOwnProperty()\n        每个实例对象都有一个hasOwnProperty()方法，\n        用来判断某一个属性到底是本地属性，\n        还是继承自prototype对象的属性。\n        alert(Person1.hasOwnProperty(&quot;name&quot;)); // true\n        alert(Person1.hasOwnProperty(&quot;type&quot;)); // false\n    6.3 in运算符\n        in运算符可以用来判断，某个实例是否含有某个属性，\n        不管是不是本地属性。\n        alert(&quot;name&quot; in Person1); // true\n        alert(&quot;type&quot; in Person1); // true\n        in运算符还可以用来遍历某个对象的所有属性。\n        for(var prop in Person1) {\n         alert(&quot;Person1[&quot;+prop+&quot;]=&quot;+Person1[prop]); \n        }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"—\"><a href=\"#—\" class=\"headerlink\" title=\"—\"></a>—</h2><pre><code>1. Javascript面向对象编程\n    Javascript不是一种真正的面向对象编程（OOP）语言，\n    语法中没有类的概念，却又是基于对象（object-based）的语言，\n    你遇到的所有东西几乎都是对象。\n    所以我们用构造函数的方法给一个函数加上属性和方法，成为一个对象。\n</code></pre><hr>\n<pre><code>2. 假定我们把Person看成一个对象，它有&quot;名字&quot;和&quot;颜色&quot;两个属性。\n    var Person = {\n        name : &apos;&apos;,\n        age : &apos;&apos;\n    } \n    现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象\n            var Person1 = {}; // 创建一个空对象\n            Person1.name = &quot;张三&quot;; // 按照原型对象的属性赋值\n            Person1.age = &quot;33&quot;;\n            var Person2 = {};\n            Person2.name = &quot;李四&quot;;\n            Person2.age = &quot;44&quot;;\n    最简单的封装，把两个属性封装在一个对象里面。\n    两个缺点，一是如果多生成几个实例，写起来就非常麻烦；\n    二是实例与原型之间，没有任何办法，可以看出有什么联系\n</code></pre><hr>\n<pre><code>3. 原始模式的改进\n    我们可以写一个函数，解决代码重复的问题。\n        function Person(name,age) {\n            return { \n                name:name,\n                age:age\n                }\n            }\n    然后生成实例对象，就等于是在调用函数：\n    var Person1 = Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = Person(&quot;李四&quot;,&quot;44&quot;);\n    这种方法的问题依然是，Person1和Person2之间没有内在的联系，\n    不能反映出它们是同一个原型对象的实例。\n</code></pre><hr>\n<pre><code>4. 构造函数模式\n    为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数\n    （Constructor）模式。\n    所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。\n    对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n    比如，猫的原型对象现在可以这样写，\n    function Person(name,age){\n        this.name=name;\n        this.age=age;\n    }\n    我们现在就可以生成实例对象了。\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.name); // 张三\n    alert(Person1.age); // 33这时Person1和Person2会自动含有一个\n    constructor属性，指向它们的构造函数。\n    alert(Person1.constructor == Person); //true\n    alert(Person2.constructor == Person); //true\n    Javascript还提供了一个instanceof运算符，验证原型对象\n    与实例对象之间的关系。\n    alert(Person1 instanceof Person); //true\n    alert(Person2 instanceof Person); //true\n    构造函数模式的问题\n    构造函数方法很好用，但是存在一个浪费内存的问题。\n    请看，我们现在为Person对象添加一个不变的属性type（种类），\n    再添加一个方法eat（吃）。那么，原型对象Person就变成了下面这样：\n    function Person(name,age){\n        this.name = name;\n        this.age = age;\n        this.type = &quot;人&quot;;\n        this.eat = function(){alert(&quot;吃饭&quot;);};\n        }\n    还是采用同样的方法，生成实例：\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person (&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.type); // 人\n    Person1.eat(); // 吃饭\n    表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。\n    对于每一个实例对象，type属性和eat()方法都是一模一样的内容，\n    每一次生成一个实例，都必须为重复的内容，多占用一些内存。\n    这样既不环保，也缺乏效率。\n    alert(Person1.eat == Person2.eat); //false\n    能不能让type属性和eat()方法在内存中只生成一次，\n    然后所有实例都指向那个内存地址呢？回答是可以的。\n</code></pre><hr>\n<pre><code>5. Prototype模式\n    Javascript规定，每一个构造函数都有一个prototype属性，\n    指向另一个对象。\n    这个对象的所有属性和方法，都会被构造函数的实例继承。\n    这意味着，我们可以把那些不变的属性和方法，\n    直接定义在prototype对象上。\n    function Person(name,age){\n        this.name = name;\n        this.age = age;\n    }\n    Person.prototype.type = &quot;人&quot;;\n    Person.prototype.eat = function(){alert(&quot;吃饭&quot;)};\n    然后，生成实例。\n    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);\n    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);\n    alert(Person1.type); // 人\n    Person1.eat(); // 吃饭\n    这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，\n    因此就提高了运行效率。\n    alert(Person1.eat == Person2.eat); //true\n</code></pre><hr>\n<pre><code>6. Prototype模式的验证方法\n为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，\n    6.1 isPrototypeOf()\n        这个方法用来判断，某个proptotype对象和某个实例之间的关系。\n        alert(Person.prototype.isPrototypeOf(Person1)); //true\n        alert(Person.prototype.isPrototypeOf(Person2)); //true\n    6.2 hasOwnProperty()\n        每个实例对象都有一个hasOwnProperty()方法，\n        用来判断某一个属性到底是本地属性，\n        还是继承自prototype对象的属性。\n        alert(Person1.hasOwnProperty(&quot;name&quot;)); // true\n        alert(Person1.hasOwnProperty(&quot;type&quot;)); // false\n    6.3 in运算符\n        in运算符可以用来判断，某个实例是否含有某个属性，\n        不管是不是本地属性。\n        alert(&quot;name&quot; in Person1); // true\n        alert(&quot;type&quot; in Person1); // true\n        in运算符还可以用来遍历某个对象的所有属性。\n        for(var prop in Person1) {\n         alert(&quot;Person1[&quot;+prop+&quot;]=&quot;+Person1[prop]); \n        }\n</code></pre>"},{"title":"Sublime text 3 部分插件","date":"2016-11-21T06:38:53.000Z","_content":"    1. autofilename\n---\n    2. Alignment\n---\n    3. Babel\n---\n    4. HTML Beautify\n---\n    5. File Header\n---\n    6. Git, GitGutter","source":"_posts/Sublime-text-3-部分插件.md","raw":"---\ntitle: Sublime text 3 部分插件\ndate: 2016-11-21 14:38:53\ntags:\n---\n    1. autofilename\n---\n    2. Alignment\n---\n    3. Babel\n---\n    4. HTML Beautify\n---\n    5. File Header\n---\n    6. Git, GitGutter","slug":"Sublime-text-3-部分插件","published":1,"updated":"2017-06-12T03:27:50.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4n00054wusbx7z43ul","content":"<pre><code>1. autofilename\n</code></pre><hr>\n<pre><code>2. Alignment\n</code></pre><hr>\n<pre><code>3. Babel\n</code></pre><hr>\n<pre><code>4. HTML Beautify\n</code></pre><hr>\n<pre><code>5. File Header\n</code></pre><hr>\n<pre><code>6. Git, GitGutter\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>1. autofilename\n</code></pre><hr>\n<pre><code>2. Alignment\n</code></pre><hr>\n<pre><code>3. Babel\n</code></pre><hr>\n<pre><code>4. HTML Beautify\n</code></pre><hr>\n<pre><code>5. File Header\n</code></pre><hr>\n<pre><code>6. Git, GitGutter\n</code></pre>"},{"title":"Windows下的nodejs管理工具nvm","date":"2016-10-15T09:01:16.000Z","_content":"\t1. github上下载nvm管理工具\n\t\thttps://github.com/coreybutler/nvm-windows.git\n\t\t最好在nvm外加一层目录\n---\n\t2. 生成配置文件和环境变量\n\t\t用管理员身份打开install.cmd\n\t\t输入nvm路径\n\t\t可能需要两次\n\t\t编辑生成的settings.txt\n\t\troot: D:\\develop\\nvm (不用改)\n\t\tpath: D:\\develop\\nodejs (改成nvm同级即可)\n---\n\t3. 修改生成的环境变量\n\t\tpath: D:\\develop\\nodejs\n\t\tNVM_SYMLINK:D:\\develop\\nodejs\n\t\tNPM_HOME:D:\\develop\\nvm\\npm\n\t\tpath:%NPM_HOME%\n---\n\t4. 设置使用版本\n\t\tnvm list\n\t\tnvm use *.*.*\n\t\tnvm list或者node -v\n---\n\t5. 设置node下载和缓存\n\t\t用户文件夹下建立.npmrc\n\t\t设置\n\t\tcache=D:\\develop\\nvm\\npm-cache\n\t\tprefix=D:\\develop\\nvm\\npm\n---\n\t6. 使用npm install -g ***测试是否完成","source":"_posts/Windows下的nodejs管理工具nvm.md","raw":"---\ntitle: Windows下的nodejs管理工具nvm\ndate: 2016-10-15 17:01:16\ntags:\n---\n\t1. github上下载nvm管理工具\n\t\thttps://github.com/coreybutler/nvm-windows.git\n\t\t最好在nvm外加一层目录\n---\n\t2. 生成配置文件和环境变量\n\t\t用管理员身份打开install.cmd\n\t\t输入nvm路径\n\t\t可能需要两次\n\t\t编辑生成的settings.txt\n\t\troot: D:\\develop\\nvm (不用改)\n\t\tpath: D:\\develop\\nodejs (改成nvm同级即可)\n---\n\t3. 修改生成的环境变量\n\t\tpath: D:\\develop\\nodejs\n\t\tNVM_SYMLINK:D:\\develop\\nodejs\n\t\tNPM_HOME:D:\\develop\\nvm\\npm\n\t\tpath:%NPM_HOME%\n---\n\t4. 设置使用版本\n\t\tnvm list\n\t\tnvm use *.*.*\n\t\tnvm list或者node -v\n---\n\t5. 设置node下载和缓存\n\t\t用户文件夹下建立.npmrc\n\t\t设置\n\t\tcache=D:\\develop\\nvm\\npm-cache\n\t\tprefix=D:\\develop\\nvm\\npm\n---\n\t6. 使用npm install -g ***测试是否完成","slug":"Windows下的nodejs管理工具nvm","published":1,"updated":"2017-06-12T03:27:50.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tl0e4p00064wusntr4ulmo","content":"<pre><code>1. github上下载nvm管理工具\n    https://github.com/coreybutler/nvm-windows.git\n    最好在nvm外加一层目录\n</code></pre><hr>\n<pre><code>2. 生成配置文件和环境变量\n    用管理员身份打开install.cmd\n    输入nvm路径\n    可能需要两次\n    编辑生成的settings.txt\n    root: D:\\develop\\nvm (不用改)\n    path: D:\\develop\\nodejs (改成nvm同级即可)\n</code></pre><hr>\n<pre><code>3. 修改生成的环境变量\n    path: D:\\develop\\nodejs\n    NVM_SYMLINK:D:\\develop\\nodejs\n    NPM_HOME:D:\\develop\\nvm\\npm\n    path:%NPM_HOME%\n</code></pre><hr>\n<pre><code>4. 设置使用版本\n    nvm list\n    nvm use *.*.*\n    nvm list或者node -v\n</code></pre><hr>\n<pre><code>5. 设置node下载和缓存\n    用户文件夹下建立.npmrc\n    设置\n    cache=D:\\develop\\nvm\\npm-cache\n    prefix=D:\\develop\\nvm\\npm\n</code></pre><hr>\n<pre><code>6. 使用npm install -g ***测试是否完成\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>1. github上下载nvm管理工具\n    https://github.com/coreybutler/nvm-windows.git\n    最好在nvm外加一层目录\n</code></pre><hr>\n<pre><code>2. 生成配置文件和环境变量\n    用管理员身份打开install.cmd\n    输入nvm路径\n    可能需要两次\n    编辑生成的settings.txt\n    root: D:\\develop\\nvm (不用改)\n    path: D:\\develop\\nodejs (改成nvm同级即可)\n</code></pre><hr>\n<pre><code>3. 修改生成的环境变量\n    path: D:\\develop\\nodejs\n    NVM_SYMLINK:D:\\develop\\nodejs\n    NPM_HOME:D:\\develop\\nvm\\npm\n    path:%NPM_HOME%\n</code></pre><hr>\n<pre><code>4. 设置使用版本\n    nvm list\n    nvm use *.*.*\n    nvm list或者node -v\n</code></pre><hr>\n<pre><code>5. 设置node下载和缓存\n    用户文件夹下建立.npmrc\n    设置\n    cache=D:\\develop\\nvm\\npm-cache\n    prefix=D:\\develop\\nvm\\npm\n</code></pre><hr>\n<pre><code>6. 使用npm install -g ***测试是否完成\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}